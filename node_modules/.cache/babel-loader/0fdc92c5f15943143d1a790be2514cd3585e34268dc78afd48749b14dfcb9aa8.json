{"ast":null,"code":"import kebabCase from 'lodash/kebabCase.js';\nimport '@aws-amplify/core/internals/utils';\nimport '../../utils/setUserAgent/constants.mjs';\nimport { isObject, has, isString } from '../../utils/utils.mjs';\nconst CSS_VARIABLE_PREFIX = 'amplify';\n/**\n * This will take an object like:\n * {paddingTop:'20px',color:'{colors.font.primary}'}\n * and turn it into a CSS string:\n * `padding-top:20px; color: var(--colors-font-primary);`\n */\nfunction propsToString(props) {\n  return Object.entries(props).map(([key, value]) => {\n    const _value = isDesignToken(value) ? value.toString() :\n    // @ts-ignore\n    cssValue({\n      value\n    });\n    return `${kebabCase(key)}:${_value}; `;\n  }).join(' ');\n}\nfunction cssNameTransform({\n  path = []\n}) {\n  return `${kebabCase([CSS_VARIABLE_PREFIX, ...path].join(' '))}`;\n}\n// Important: these properties should not be altered in\n// order to maintain the expected order of the CSS `box-shadow` property\nconst SHADOW_PROPERTIES = ['offsetX', 'offsetY', 'blurRadius', 'spreadRadius', 'color'];\n/**\n * Will take a design token in a theme and return its value as CSS\n *\n * @param token\n * @returns\n */\nfunction cssValue(token) {\n  const {\n    value\n  } = token;\n  if (isString(value)) {\n    return referenceValue(value);\n  }\n  if (isShadowTokenObject(value)) {\n    return SHADOW_PROPERTIES.map(property => {\n      return referenceValue(\n      // lookup property against `token` first for custom non-nested value, then lookup\n      // property against `value` for design token value\n      isShadowTokenObject(token) ? token[property] : value[property]);\n    }).join(' ');\n  }\n  return value;\n}\n/**\n * Helper function to test if something is a design token or not.\n * Used in the React component style props.\n *\n * @param value - thing to test if it is a design token or not\n * @returns boolean\n */\nfunction isDesignToken(value) {\n  return isObject(value) && has(value, 'value');\n}\nfunction isShadowTokenObject(value) {\n  return isObject(value) && has(value, 'offsetX');\n}\n/**\n * Function that sees if a string contains a design token reference\n * and if so will turn that into a CSS variable.\n *\n * @param {string} value\n * @returns string\n */\nfunction referenceValue(value) {\n  if (!value) return '';\n  if (usesReference(value)) {\n    const path = value.replace(/\\{|\\}/g, '').replace('.value', '').split('.');\n    return `var(--${cssNameTransform({\n      path\n    })})`;\n  }\n  return value;\n}\n/**\n * This will take a design token and add some data to it for it\n * to be used in JS/CSS. It will create its CSS var name and update\n * the value to use a CSS var if it is a reference. It will also\n * add a `.toString()` method to make it easier to use in JS.\n *\n * We should see if there is a way to share this logic with style dictionary...\n */\nconst setupToken = ({\n  token,\n  path\n}) => {\n  const name = `--${cssNameTransform({\n    path\n  })}`;\n  const {\n    value: original\n  } = token;\n  const value = cssValue(token);\n  return {\n    name,\n    original,\n    path,\n    value,\n    toString: () => `var(${name})`\n  };\n};\n/**\n * Recursive function that will walk down the token object\n * and perform the setupToken function on each token.\n * Similar to what Style Dictionary does.\n */\nfunction setupTokens({\n  tokens,\n  path = [],\n  setupToken\n}) {\n  if (has(tokens, 'value')) {\n    return setupToken({\n      token: tokens,\n      path\n    });\n  }\n  const output = {};\n  for (const name in tokens) {\n    if (has(tokens, name)) {\n      const value = tokens[name];\n      const nextTokens = isObject(value) ? value : {\n        value\n      };\n      output[name] = setupTokens({\n        tokens: nextTokens,\n        path: path.concat(name),\n        setupToken\n      });\n    }\n  }\n  return output;\n}\n// Internal Style Dictionary methods\n// copied from amzn/style-dictionary with the owner's permission\n/**\n * Takes an plain javascript object and will make a flat array of all the leaf nodes.\n * A leaf node in this context has a 'value' property. Potentially refactor this to\n * be more generic.\n * @private\n * @param  {Object} properties - The plain object you want flattened into an array.\n * @param  {Array} [to_ret=[]] - Properties array. This function is recursive therefore this is what gets passed along.\n * @return {Array}\n */\nfunction flattenProperties(properties, to_ret) {\n  to_ret = to_ret || [];\n  for (var name in properties) {\n    if (has(properties, name)) {\n      if (isObject(properties[name]) && 'value' in properties[name]) {\n        to_ret.push(properties[name]);\n      } else if (isObject(properties[name])) {\n        flattenProperties(properties[name], to_ret);\n      }\n    }\n  }\n  return to_ret;\n}\n/**\n * Performs an deep extend on the objects, from right to left.\n * @private\n * @param {Object[]} objects - An array of JS objects\n * @param {Function} collision - A function to be called when a merge collision happens.\n * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.\n * @returns {Object}\n */\nfunction deepExtend(objects, collision, path) {\n  if (objects == null) return {};\n  var src,\n    copyIsArray,\n    copy,\n    name,\n    options,\n    clone,\n    target = objects[0] || {},\n    i = 1,\n    length = objects.length;\n  path = path || [];\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== 'object') {\n    target = {};\n  }\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = objects[i]) != null) {\n      // Extend the base object\n      for (name in options) {\n        if (!has(options, name)) continue;\n        if (name === '__proto__') continue;\n        src = target[name];\n        copy = options[name];\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n        // Recurse if we're merging plain objects or arrays\n        if (copy && (isObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src && Array.isArray(src) ? src : [];\n          } else {\n            clone = src && isObject(src) ? src : {};\n          }\n          var nextPath = path.slice(0);\n          nextPath.push(name);\n          // Never move original objects, clone them\n          target[name] = deepExtend([clone, copy], collision, nextPath);\n          // Don't bring in undefined values\n        } else if (copy !== undefined) {\n          if (src != null && typeof collision == 'function') {\n            collision({\n              target: target,\n              copy: options,\n              path: path,\n              key: name\n            });\n          }\n          target[name] = copy;\n        }\n      }\n    }\n  }\n  return target;\n}\n/**\n * Checks if the value uses a value reference.\n * @param {string} value\n * @returns {boolean} - True, if the value uses a value reference\n */\nfunction usesReference(value) {\n  const regex = new RegExp('\\\\{([^}]+)\\\\}', 'g');\n  if (typeof value === 'string') {\n    return regex.test(value);\n  }\n  if (typeof value === 'object') {\n    let hasReference = false;\n    // iterate over each property in the object,\n    // if any element passes the regex test,\n    // the whole thing should be true\n    for (const key in value) {\n      if (has(value, key)) {\n        const element = value[key];\n        let reference = usesReference(element);\n        if (reference) {\n          hasReference = true;\n          break;\n        }\n      }\n    }\n    return hasReference;\n  }\n  return false;\n}\nexport { CSS_VARIABLE_PREFIX, cssNameTransform, cssValue, deepExtend, flattenProperties, isDesignToken, isShadowTokenObject, propsToString, referenceValue, setupToken, setupTokens, usesReference };","map":{"version":3,"names":["kebabCase","isObject","has","isString","CSS_VARIABLE_PREFIX","propsToString","props","Object","entries","map","key","value","_value","isDesignToken","toString","cssValue","join","cssNameTransform","path","SHADOW_PROPERTIES","token","referenceValue","isShadowTokenObject","property","usesReference","replace","split","setupToken","name","original","setupTokens","tokens","output","nextTokens","concat","flattenProperties","properties","to_ret","push","deepExtend","objects","collision","src","copyIsArray","copy","options","clone","target","i","length","Array","isArray","nextPath","slice","undefined","regex","RegExp","test","hasReference","element","reference"],"sources":["/Users/kriziafrias/Documents/GitHub/hbaacademy/node_modules/.pnpm/@aws-amplify+ui@6.4.1_oj47ictm6if4ippeizmzzmttvm/node_modules/@aws-amplify/ui/dist/esm/theme/createTheme/utils.mjs"],"sourcesContent":["import kebabCase from 'lodash/kebabCase.js';\nimport '@aws-amplify/core/internals/utils';\nimport '../../utils/setUserAgent/constants.mjs';\nimport { isObject, has, isString } from '../../utils/utils.mjs';\n\nconst CSS_VARIABLE_PREFIX = 'amplify';\n/**\n * This will take an object like:\n * {paddingTop:'20px',color:'{colors.font.primary}'}\n * and turn it into a CSS string:\n * `padding-top:20px; color: var(--colors-font-primary);`\n */\nfunction propsToString(props) {\n    return Object.entries(props)\n        .map(([key, value]) => {\n        const _value = isDesignToken(value)\n            ? value.toString()\n            : // @ts-ignore\n                cssValue({ value });\n        return `${kebabCase(key)}:${_value}; `;\n    })\n        .join(' ');\n}\nfunction cssNameTransform({ path = [] }) {\n    return `${kebabCase([CSS_VARIABLE_PREFIX, ...path].join(' '))}`;\n}\n// Important: these properties should not be altered in\n// order to maintain the expected order of the CSS `box-shadow` property\nconst SHADOW_PROPERTIES = [\n    'offsetX',\n    'offsetY',\n    'blurRadius',\n    'spreadRadius',\n    'color',\n];\n/**\n * Will take a design token in a theme and return its value as CSS\n *\n * @param token\n * @returns\n */\nfunction cssValue(token) {\n    const { value } = token;\n    if (isString(value)) {\n        return referenceValue(value);\n    }\n    if (isShadowTokenObject(value)) {\n        return SHADOW_PROPERTIES.map((property) => {\n            return referenceValue(\n            // lookup property against `token` first for custom non-nested value, then lookup\n            // property against `value` for design token value\n            isShadowTokenObject(token) ? token[property] : value[property]);\n        }).join(' ');\n    }\n    return value;\n}\n/**\n * Helper function to test if something is a design token or not.\n * Used in the React component style props.\n *\n * @param value - thing to test if it is a design token or not\n * @returns boolean\n */\nfunction isDesignToken(value) {\n    return isObject(value) && has(value, 'value');\n}\nfunction isShadowTokenObject(value) {\n    return isObject(value) && has(value, 'offsetX');\n}\n/**\n * Function that sees if a string contains a design token reference\n * and if so will turn that into a CSS variable.\n *\n * @param {string} value\n * @returns string\n */\nfunction referenceValue(value) {\n    if (!value)\n        return '';\n    if (usesReference(value)) {\n        const path = value.replace(/\\{|\\}/g, '').replace('.value', '').split('.');\n        return `var(--${cssNameTransform({ path })})`;\n    }\n    return value;\n}\n/**\n * This will take a design token and add some data to it for it\n * to be used in JS/CSS. It will create its CSS var name and update\n * the value to use a CSS var if it is a reference. It will also\n * add a `.toString()` method to make it easier to use in JS.\n *\n * We should see if there is a way to share this logic with style dictionary...\n */\nconst setupToken = ({ token, path }) => {\n    const name = `--${cssNameTransform({ path })}`;\n    const { value: original } = token;\n    const value = cssValue(token);\n    return { name, original, path, value, toString: () => `var(${name})` };\n};\n/**\n * Recursive function that will walk down the token object\n * and perform the setupToken function on each token.\n * Similar to what Style Dictionary does.\n */\nfunction setupTokens({ tokens, path = [], setupToken, }) {\n    if (has(tokens, 'value')) {\n        return setupToken({ token: tokens, path });\n    }\n    const output = {};\n    for (const name in tokens) {\n        if (has(tokens, name)) {\n            const value = tokens[name];\n            const nextTokens = isObject(value) ? value : { value };\n            output[name] = setupTokens({\n                tokens: nextTokens,\n                path: path.concat(name),\n                setupToken,\n            });\n        }\n    }\n    return output;\n}\n// Internal Style Dictionary methods\n// copied from amzn/style-dictionary with the owner's permission\n/**\n * Takes an plain javascript object and will make a flat array of all the leaf nodes.\n * A leaf node in this context has a 'value' property. Potentially refactor this to\n * be more generic.\n * @private\n * @param  {Object} properties - The plain object you want flattened into an array.\n * @param  {Array} [to_ret=[]] - Properties array. This function is recursive therefore this is what gets passed along.\n * @return {Array}\n */\nfunction flattenProperties(properties, to_ret) {\n    to_ret = to_ret || [];\n    for (var name in properties) {\n        if (has(properties, name)) {\n            if (isObject(properties[name]) && 'value' in properties[name]) {\n                to_ret.push(properties[name]);\n            }\n            else if (isObject(properties[name])) {\n                flattenProperties(properties[name], to_ret);\n            }\n        }\n    }\n    return to_ret;\n}\n/**\n * Performs an deep extend on the objects, from right to left.\n * @private\n * @param {Object[]} objects - An array of JS objects\n * @param {Function} collision - A function to be called when a merge collision happens.\n * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.\n * @returns {Object}\n */\nfunction deepExtend(objects, collision, path) {\n    if (objects == null)\n        return {};\n    var src, copyIsArray, copy, name, options, clone, target = objects[0] || {}, i = 1, length = objects.length;\n    path = path || [];\n    // Handle case when target is a string or something (possible in deep copy)\n    if (typeof target !== 'object') {\n        target = {};\n    }\n    for (; i < length; i++) {\n        // Only deal with non-null/undefined values\n        if ((options = objects[i]) != null) {\n            // Extend the base object\n            for (name in options) {\n                if (!has(options, name))\n                    continue;\n                if (name === '__proto__')\n                    continue;\n                src = target[name];\n                copy = options[name];\n                // Prevent never-ending loop\n                if (target === copy) {\n                    continue;\n                }\n                // Recurse if we're merging plain objects or arrays\n                if (copy && (isObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        clone = src && Array.isArray(src) ? src : [];\n                    }\n                    else {\n                        clone = src && isObject(src) ? src : {};\n                    }\n                    var nextPath = path.slice(0);\n                    nextPath.push(name);\n                    // Never move original objects, clone them\n                    target[name] = deepExtend([clone, copy], collision, nextPath);\n                    // Don't bring in undefined values\n                }\n                else if (copy !== undefined) {\n                    if (src != null && typeof collision == 'function') {\n                        collision({ target: target, copy: options, path: path, key: name });\n                    }\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n    return target;\n}\n/**\n * Checks if the value uses a value reference.\n * @param {string} value\n * @returns {boolean} - True, if the value uses a value reference\n */\nfunction usesReference(value) {\n    const regex = new RegExp('\\\\{([^}]+)\\\\}', 'g');\n    if (typeof value === 'string') {\n        return regex.test(value);\n    }\n    if (typeof value === 'object') {\n        let hasReference = false;\n        // iterate over each property in the object,\n        // if any element passes the regex test,\n        // the whole thing should be true\n        for (const key in value) {\n            if (has(value, key)) {\n                const element = value[key];\n                let reference = usesReference(element);\n                if (reference) {\n                    hasReference = true;\n                    break;\n                }\n            }\n        }\n        return hasReference;\n    }\n    return false;\n}\n\nexport { CSS_VARIABLE_PREFIX, cssNameTransform, cssValue, deepExtend, flattenProperties, isDesignToken, isShadowTokenObject, propsToString, referenceValue, setupToken, setupTokens, usesReference };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}