{"ast":null,"code":"import { StorageAction } from '@aws-amplify/core/internals/utils';\nimport '@smithy/md5-js';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport '../../utils/client/runtime/s3TransferHandler/fetch.mjs';\nimport 'fast-xml-parser';\nimport '../../utils/client/runtime/s3TransferHandler/xhr.mjs';\nimport 'buffer';\nimport { resolveS3ConfigAndInput } from '../../utils/resolveS3ConfigAndInput.mjs';\nimport { assertValidationError } from '../../../../errors/utils/assertValidationError.mjs';\nimport { StorageValidationErrorCode } from '../../../../errors/types/validation.mjs';\nimport { logger } from '../../../../utils/logger.mjs';\nimport { validateStorageOperationInput } from '../../utils/validateStorageOperationInput.mjs';\nimport { isInputWithPath } from '../../utils/isInputWithPath.mjs';\nimport '../../utils/client/base.mjs';\nimport '../../utils/client/getObject.mjs';\nimport '../../utils/client/listObjectsV2.mjs';\nimport '../../utils/client/putObject.mjs';\nimport '../../utils/client/createMultipartUpload.mjs';\nimport '../../utils/client/uploadPart.mjs';\nimport '../../utils/client/completeMultipartUpload.mjs';\nimport '../../utils/client/listParts.mjs';\nimport '../../utils/client/abortMultipartUpload.mjs';\nimport { copyObject } from '../../utils/client/copyObject.mjs';\nimport '../../utils/client/headObject.mjs';\nimport '../../utils/client/deleteObject.mjs';\nimport { getStorageUserAgentValue } from '../../utils/userAgent.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst isCopyInputWithPath = input => isInputWithPath(input.source);\nconst storageBucketAssertion = (sourceBucket, destBucket) => {\n  /**  For multi-bucket, both source and destination bucket needs to be passed in\n   *   or both can be undefined and we fallback to singleton's default value\n   */\n  assertValidationError(\n  // Both src & dest bucket option is present is acceptable\n  sourceBucket !== undefined && destBucket !== undefined ||\n  // or both are undefined is also acceptable\n  !destBucket && !sourceBucket, StorageValidationErrorCode.InvalidCopyOperationStorageBucket);\n};\nconst copy = async (amplify, input) => {\n  return isCopyInputWithPath(input) ? copyWithPath(amplify, input) : copyWithKey(amplify, input);\n};\nconst copyWithPath = async (amplify, input) => {\n  const {\n    source,\n    destination\n  } = input;\n  storageBucketAssertion(source.bucket, destination.bucket);\n  const {\n    bucket: sourceBucket,\n    identityId\n  } = await resolveS3ConfigAndInput(amplify, input.source);\n  const {\n    s3Config,\n    bucket: destBucket\n  } = await resolveS3ConfigAndInput(amplify, input.destination); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n  assertValidationError(!!source.path, StorageValidationErrorCode.NoSourcePath);\n  assertValidationError(!!destination.path, StorageValidationErrorCode.NoDestinationPath);\n  const {\n    objectKey: sourcePath\n  } = validateStorageOperationInput(source, identityId);\n  const {\n    objectKey: destinationPath\n  } = validateStorageOperationInput(destination, identityId);\n  const finalCopySource = `${sourceBucket}/${sourcePath}`;\n  const finalCopyDestination = destinationPath;\n  logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n  await serviceCopy({\n    source: finalCopySource,\n    destination: finalCopyDestination,\n    bucket: destBucket,\n    s3Config\n  });\n  return {\n    path: finalCopyDestination\n  };\n};\n/** @deprecated Use {@link copyWithPath} instead. */\nconst copyWithKey = async (amplify, input) => {\n  const {\n    source,\n    destination\n  } = input;\n  storageBucketAssertion(source.bucket, destination.bucket);\n  assertValidationError(!!source.key, StorageValidationErrorCode.NoSourceKey);\n  assertValidationError(!!destination.key, StorageValidationErrorCode.NoDestinationKey);\n  const {\n    bucket: sourceBucket,\n    keyPrefix: sourceKeyPrefix\n  } = await resolveS3ConfigAndInput(amplify, source);\n  const {\n    s3Config,\n    bucket: destBucket,\n    keyPrefix: destinationKeyPrefix\n  } = await resolveS3ConfigAndInput(amplify, destination); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n  // TODO(ashwinkumar6) V6-logger: warn `You may copy files from another user if the source level is \"protected\", currently it's ${srcLevel}`\n  const finalCopySource = `${sourceBucket}/${sourceKeyPrefix}${source.key}`;\n  const finalCopyDestination = `${destinationKeyPrefix}${destination.key}`;\n  logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n  await serviceCopy({\n    source: finalCopySource,\n    destination: finalCopyDestination,\n    bucket: destBucket,\n    s3Config\n  });\n  return {\n    key: destination.key\n  };\n};\nconst serviceCopy = async ({\n  source,\n  destination,\n  bucket,\n  s3Config\n}) => {\n  await copyObject({\n    ...s3Config,\n    userAgentValue: getStorageUserAgentValue(StorageAction.Copy)\n  }, {\n    Bucket: bucket,\n    CopySource: source,\n    Key: destination,\n    MetadataDirective: 'COPY' // Copies over metadata like contentType as well\n  });\n};\nexport { copy, copyWithKey };","map":{"version":3,"names":["isCopyInputWithPath","input","isInputWithPath","source","storageBucketAssertion","sourceBucket","destBucket","assertValidationError","undefined","StorageValidationErrorCode","InvalidCopyOperationStorageBucket","copy","amplify","copyWithPath","copyWithKey","destination","bucket","identityId","resolveS3ConfigAndInput","s3Config","path","NoSourcePath","NoDestinationPath","objectKey","sourcePath","validateStorageOperationInput","destinationPath","finalCopySource","finalCopyDestination","logger","debug","serviceCopy","key","NoSourceKey","NoDestinationKey","keyPrefix","sourceKeyPrefix","destinationKeyPrefix","copyObject","userAgentValue","getStorageUserAgentValue","StorageAction","Copy","Bucket","CopySource","Key","MetadataDirective"],"sources":["/Users/kriziafrias/Documents/GitHub/hbaacademy/node_modules/@aws-amplify/storage/src/providers/s3/apis/internal/copy.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { StorageAction } from '@aws-amplify/core/internals/utils';\nimport { isInputWithPath, resolveS3ConfigAndInput, validateStorageOperationInput, } from '../../utils';\nimport { StorageValidationErrorCode } from '../../../../errors/types/validation';\nimport { assertValidationError } from '../../../../errors/utils/assertValidationError';\nimport { copyObject } from '../../utils/client';\nimport { getStorageUserAgentValue } from '../../utils/userAgent';\nimport { logger } from '../../../../utils';\nconst isCopyInputWithPath = (input) => isInputWithPath(input.source);\nconst storageBucketAssertion = (sourceBucket, destBucket) => {\n    /**  For multi-bucket, both source and destination bucket needs to be passed in\n     *   or both can be undefined and we fallback to singleton's default value\n     */\n    assertValidationError(\n    // Both src & dest bucket option is present is acceptable\n    (sourceBucket !== undefined && destBucket !== undefined) ||\n        // or both are undefined is also acceptable\n        (!destBucket && !sourceBucket), StorageValidationErrorCode.InvalidCopyOperationStorageBucket);\n};\nexport const copy = async (amplify, input) => {\n    return isCopyInputWithPath(input)\n        ? copyWithPath(amplify, input)\n        : copyWithKey(amplify, input);\n};\nconst copyWithPath = async (amplify, input) => {\n    const { source, destination } = input;\n    storageBucketAssertion(source.bucket, destination.bucket);\n    const { bucket: sourceBucket, identityId } = await resolveS3ConfigAndInput(amplify, input.source);\n    const { s3Config, bucket: destBucket } = await resolveS3ConfigAndInput(amplify, input.destination); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n    assertValidationError(!!source.path, StorageValidationErrorCode.NoSourcePath);\n    assertValidationError(!!destination.path, StorageValidationErrorCode.NoDestinationPath);\n    const { objectKey: sourcePath } = validateStorageOperationInput(source, identityId);\n    const { objectKey: destinationPath } = validateStorageOperationInput(destination, identityId);\n    const finalCopySource = `${sourceBucket}/${sourcePath}`;\n    const finalCopyDestination = destinationPath;\n    logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n    await serviceCopy({\n        source: finalCopySource,\n        destination: finalCopyDestination,\n        bucket: destBucket,\n        s3Config,\n    });\n    return { path: finalCopyDestination };\n};\n/** @deprecated Use {@link copyWithPath} instead. */\nexport const copyWithKey = async (amplify, input) => {\n    const { source, destination } = input;\n    storageBucketAssertion(source.bucket, destination.bucket);\n    assertValidationError(!!source.key, StorageValidationErrorCode.NoSourceKey);\n    assertValidationError(!!destination.key, StorageValidationErrorCode.NoDestinationKey);\n    const { bucket: sourceBucket, keyPrefix: sourceKeyPrefix } = await resolveS3ConfigAndInput(amplify, source);\n    const { s3Config, bucket: destBucket, keyPrefix: destinationKeyPrefix, } = await resolveS3ConfigAndInput(amplify, destination); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n    // TODO(ashwinkumar6) V6-logger: warn `You may copy files from another user if the source level is \"protected\", currently it's ${srcLevel}`\n    const finalCopySource = `${sourceBucket}/${sourceKeyPrefix}${source.key}`;\n    const finalCopyDestination = `${destinationKeyPrefix}${destination.key}`;\n    logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n    await serviceCopy({\n        source: finalCopySource,\n        destination: finalCopyDestination,\n        bucket: destBucket,\n        s3Config,\n    });\n    return {\n        key: destination.key,\n    };\n};\nconst serviceCopy = async ({ source, destination, bucket, s3Config, }) => {\n    await copyObject({\n        ...s3Config,\n        userAgentValue: getStorageUserAgentValue(StorageAction.Copy),\n    }, {\n        Bucket: bucket,\n        CopySource: source,\n        Key: destination,\n        MetadataDirective: 'COPY', // Copies over metadata like contentType as well\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}